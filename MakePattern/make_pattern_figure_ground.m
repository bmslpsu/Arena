function [pattern] = make_pattern_figure_ground(figwidth, wave, res, h, rc, xy, root)
%% make_pattern_figure_gorund: makes pattern with two channels
%  Channel-1: rotates background
%  Channel-2: rotates bar
%
%   INPUTS:
%       figwidth    : barwidth in pixels
%       wave        : spatial wavelength of background [°]%
%       res         : spatial resolution of arena [°]
%       h           : arena height (# of panels not pixels)
%       rc          : row compression on or off (boolean)
%       xy          : 'x' or 'y' to set rotation channel
%       root        :  directory to save pattern file
%
%   OUTPUTS:
%       pattern : parent structure
%           .x_num          -   xpos limits
%                               by convention, xpos relates to translation and
%                               rotations of a static pattern
%           .y_num          -   ypos limits
%                               by convention, ypos relates to non-length
%                               conserving transformations
%           .x_pixel        -   number of panels in x direction
%           .y_pixel        -   number of panels in y directions
%           .num_panels     -   number of panels in array
%                               (.x_panels*.y_panels)
%           .panel_size     -   '0' gives default 8x8, '1' allows user specific
%           .gs_val         -   gray scale value (1-4)
%           .Pats           -   data for the panels...a 4D array where
%                               (x_panels*x_size,y_panels*y_size,xpos,ypos)
%           .Panel_map      -   a 2x2 array specifying the location of the
%                               named panels indexed from '1'
%           .BitMapIndex	-   output generated by executing
%                               'process_panel_map(pattern);'
%           .data           -   output generated by executing
%                               'make_pattern_vector(pattern);'
%

if nargin < 7
    root = []; % don't save
    if nargin < 6
        xy = 'x'; % rotate in the x-channel
        if nargin < 5
            rc = false; % default is row compression off
            if nargin < 4
                h = 2; % default is 2 panels high
                if nargin < 3
                    res = 3.75; % default arena resolution [°]
                end
            end
        end
    end
end

% Set panel variables
pattern.xy = xy;
pattern.gs_val = 1; % pattern will use 2 intensity levels
pattern.row_compression = rc; % row compression flag
pattern.pixel_per_panel = 8; % pixels per panel
pattern.res = res; % spatial resolution of arena
pattern.height = h; % arena height (# panels)
pattern.x_pixel = 360/pattern.res;	% # of x-pixels
pattern.y_pixel = pattern.height;	% # of y-pixels

if ~pattern.row_compression % if row compression is off
    pattern.y_pixel = pattern.y_pixel * pattern.pixel_per_panel;
end

% Ensure arena resolution is attainable
assert(round(pattern.x_pixel) == pattern.x_pixel, ...
    'Arena resolution must yield an integer number of pixels')

% Set pattern channel variables
pattern.x_num = pattern.x_pixel; % background will move though each x-pixel in x-channel
pattern.y_num = pattern.x_pixel; % bar  will move though each x-pixel in y-channel
pattern.num_panels = (pattern.x_pixel/pattern.pixel_per_panel)*pattern.height; % # of unique panel IDs required

% Calculate bar widths for each wavelength
barwidth = pattern.x_num*(wave./360);

% Calculate # of cycle repetitions for each wavelength
reps = 360./wave;
reps(reps==inf) = 96;

% Ensure wavelengths yield integer barwidths, barwidths are less
% than the total number of x-pixels, & wavelength are factors of 360
waveTest = round(barwidth)==barwidth & (barwidth<=pattern.x_pixel | barwidth==inf) ...
    & round(360./wave)==(360./wave);
badWave = find(~waveTest);
if any(~waveTest)
	err = '';
    for kk = 1:length(badWave)
        err = [err,sprintf(['%1.1f' char(176) ' invalid \n'],wave(badWave(kk)))];
    end
   error([err,'Valid wavelengths are factors of 360° & divisible by 7.5°'])    
end

% Make background grating
Int.High = 1; % high intensity value (0-15)
Int.Low  = 0; % low intensity value (0-15)
Pats = zeros(pattern.y_pixel, pattern.x_pixel, pattern.x_num, pattern.y_num);
jj = 1;
if barwidth(jj) == 0 % for all panels low
    Pats(:,:, 1, jj) = Int.Low*ones(pattern.y_pixel, pattern.x_pixel);
elseif barwidth(jj) == inf % for all panels high
    Pats(:,:, 1, jj) = Int.High*ones(pattern.y_pixel, pattern.x_pixel);        
else % for any grating
    Pats(:,:, 1, jj) = repmat( [ Int.Low*ones(pattern.y_pixel,barwidth(jj)/2) , ...
                                 Int.High*ones(pattern.y_pixel,barwidth(jj)/2) ], 1, reps(jj) );
end

% Make x-channel: background rotation
for ii = 2:pattern.x_num
    Pats(:,:,ii,1) = ShiftMatrix(Pats(:,:,ii-1,1), 1, 'r', 'y'); % shift one bit to right
end
Pats_background = Pats;

% Make figure image
fig = 0*ones(1,figwidth);
fig = repmat(fig, [pattern.y_pixel 1]);

% Make y-channel: figure rotation
for ii = 1:pattern.x_num
    for jj = 1:pattern.y_num
        fig_mask = false(pattern.y_pixel, pattern.x_pixel);
        fig_mask(:,1:figwidth) = true;
        fig_mask = circshift(fig_mask, jj-1, 2);
        temp = Pats_background(:,:,ii,1);
       	temp(fig_mask) = fig;
        Pats(:,:,ii,jj) = temp;
    end
end

% Set direction of yaw rotation to x or y channel
switch pattern.xy
    case 'x' % pattern rotates in x-channel
        % already set
    case 'y' % make pattern rotate in y-channel
        Pats = permute(Pats, [1 2 4 3]);  % flip x & y channels
        x_num = pattern.x_num;
        y_num = pattern.y_num;
        pattern.y_num = x_num;
        pattern.x_num = y_num;
    otherwise
        error('"xy" must be "x" or "y"')
end 

% Store pattern data
pattern.Pats = Pats;

% Store arena panel layout
Panel_map = [12 8  4  11 7  3  10 6  2  9  5  1 ;...    
                     24 20 16 23 19 15 22 18 14 21 17 13;...
                     36 32 28 35 31 27 34 30 26 33 29 25;...
                     48 44 40 47 43 39 46 42 38 45 41 37];
pattern.Panel_map = Panel_map(1:pattern.height, :); % only for how many panels rows (up to 4)

% Make BitMap
pattern.BitMapIndex = process_panel_map(pattern);

% Make data
pattern.data = Make_pattern_vector(pattern);

% Save pattern
if ~isempty(root)
    % Name file
	str = ['pattern_fig_' num2str(figwidth) '_wave_' num2str(wave) '_gs=' num2str(pattern.gs_val) '_cont=' num2str(Int.High) ...
        '-' num2str(Int.Low) '_' num2str(pattern.num_panels) 'pannel_' pattern.xy '.mat'];
    save(fullfile(root,str), 'pattern');
end
end

